function panic<T>(msg: string): T {
    error#throw(msg)
}

type Option<T> = [Ok: T | None];

type Result<T, E> = [Ok: T | Err: E];

function isOk<'A, T>(e: ['A]): boolean
where (Ok: T) <: 'A
{
    switch (e) {
    case Ok(v): true
    case v: false
    }
}

function unwrap<'A, T>(e: ['A]): T
where (Ok: T) <: 'A
{
    switch (e) {
    case Ok(v): v
    case v: panic("unwrap error")
    }
}

interface Iterator<I> {
    next<T>(it: Iterator<T>): Option<T>;
}

interface Iterable<I> {
    iter<It: type -> type, T>(a: Iterable<T>): It<T> where Iterator<It>;
}

class ArrayIterator<T> {
    it: NativeArrayIterator<T>;

    next(): Option<T> {
        arrayIter#next(this.it)
    }
}

class Array<T> {
    a: NativeArray<T>;

    length(): number {
        array#length(this.a)
    }

    push(v: T): number {
        array#push(this.a, v)
    }

    forEach(f: (v: T) -> unit) {
        array#forEach(this.a, f)
    }

    at(i: number): Option<T> {
        array#at(this.a, i)
    }

    get(i: number): Option<T> {
        this.at(i)
    }

    set(i: number, v: T) {
        array#set(this.a, i, v)
    }

    iter(): ArrayIterator<T> {
        new ArrayIterator(array#iter(this.a))
    }
}

// TODO: Map iterator.
class Map<K, V> {
    m: NativeMap<K, V>;

    has(key: K): boolean {
        map#has(this.m, key)
    }

    get(key: K): Option<V> {
        (this.has(key)) ? Ok(map#get(this.m, key)) : None
    }

    set(key: K, value: V): Map<K, V> {
        map#set(this.m, key, value);
        this
    }

    delete(key: K): boolean {
        map#delete(this.m, key)
    }

    clear() {
        map#clear(this.m)
    }
}

declare function error#throw<T>(m: string): T;

declare function unionify<'R>(a: ['R]): ['R];

declare Reflected<T>;

declare function number#__add__(a: number, b: number): number;
declare function number#__sub__(a: number, b: number): number;
declare function number#__mul__(a: number, b: number): number;
declare function number#__div__(a: number, b: number): number;
declare function number#__mod__(a: number, b: number): number;
declare function number#__eq__(a: number, b: number): boolean;
declare function number#__neq__(a: number, b: number): boolean;
declare function number#__le__(a: number, b: number): boolean;
declare function number#__ge__(a: number, b: number): boolean;
declare function number#__lt__(a: number, b: number): boolean;
declare function number#__gt__(a: number, b: number): boolean;

declare function boolean#__or__(a: boolean, b: boolean): boolean;
declare function boolean#__and__(a: boolean, b: boolean): boolean;
declare function boolean#__not__(a: boolean): boolean;

declare NativeArrayIterator<T>;
declare function arrayIter#next<T>(a: NativeArrayIterator<T>): Option<T>;

declare NativeArray<T>;
declare function array#length<T>(a: NativeArray<T>): number;
declare function array#push<T>(a: NativeArray<T>, v: T): number;
declare function array#forEach<T>(a: NativeArray<T>, f: (v: T) -> unit);
declare function array#at<T>(a: NativeArray<T>, i: number): Option<T>;
declare function array#set<T>(a: NativeArray<T>, i: number, v: T);
declare function array#iter<T>(a: NativeArray<T>): NativeArrayIterator<T>;

declare NativeMap<K, V>;
declare function map#has<K, V>(m: NativeMap<K, V>, key: K): boolean;
declare function map#get<K, V>(m: NativeMap<K, V>, key: K): V;
declare function map#set<K, V>(m: NativeMap<K, V>, key: K, value: V);
declare function map#delete<K, V>(m: NativeMap<K, V>, key: K): boolean;
declare function map#clear<K, V>(m: NativeMap<K, V>);
