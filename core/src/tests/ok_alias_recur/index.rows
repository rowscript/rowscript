type Nat = [Z | S(Nat)];

function f0(): Nat {
    S(S(Z))
}

type MyList<T> = [
    Append({value: T, list: MyList<T>})
    | Empty
];

function isEmpty<T>(list: MyList<T>): boolean {
    switch (list) {
        case Append(a): false
        case Empty: true
    }
}

function f1(): MyList<number> {
    Empty
}
console.assert(f1().isEmpty());

function f2(): MyList<number> {
    Append({value: 42, list: Append({value: 69, list: Empty})})
}
console.assert(!f2().isEmpty());

function foldNat<T>(init: T, n: Nat, f: (a: T) => T): T {
    switch (n) {
        case S(x): foldNat(f(init), x, f)
        case Z: init
    }
}
const a3 = foldNat(0, S(S(Z)), (n) => n + 1);
console.assert(a3 == 2);

function myFold<T, ItemT>(init: T, list: MyList<ItemT>, f: (a: T, i: ItemT) => T): T {
    switch (list) {
        case Append(item): myFold(f(init, item.value), item.list, f)
        case Empty: init
    }
}
const a4 = myFold(0, f2(), (n, i) => n + i);
console.assert(a4 == 111);
